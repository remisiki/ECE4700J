;buildInfoPackage: chisel3, version: 3.3.1, scalaVersion: 2.12.11, sbtVersion: 1.3.10
circuit ISR : 
  module mult_stage : 
    input clock : Clock
    input reset : Reset
    output io : {flip start : UInt<1>, flip product_in : UInt<64>, flip mplier_in : UInt<64>, flip mcand_in : UInt<64>, done : UInt<1>, product_out : UInt<64>, mplier_out : UInt<64>, mcand_out : UInt<64>}
    
    reg productInRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 26:40]
    reg partialProductRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 27:45]
    reg doneRegister : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[ISR.scala 28:35]
    reg nextMplier : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 29:33]
    reg nextMcand : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 30:32]
    node _T = bits(io.mplier_in, 63, 8) @[ISR.scala 32:53]
    node _T_1 = cat(UInt<8>("h00"), _T) @[Cat.scala 29:58]
    nextMplier <= _T_1 @[ISR.scala 32:20]
    node _T_2 = bits(io.mcand_in, 55, 0) @[ISR.scala 33:37]
    node _T_3 = cat(_T_2, UInt<8>("h00")) @[Cat.scala 29:58]
    nextMcand <= _T_3 @[ISR.scala 33:19]
    productInRegister <= io.product_in @[ISR.scala 35:27]
    node _T_4 = bits(io.mplier_in, 7, 0) @[ISR.scala 36:47]
    node _T_5 = mul(_T_4, io.mcand_in) @[ISR.scala 36:62]
    partialProductRegister <= _T_5 @[ISR.scala 36:32]
    doneRegister <= io.start @[ISR.scala 37:22]
    node _T_6 = add(productInRegister, partialProductRegister) @[ISR.scala 39:45]
    node _T_7 = tail(_T_6, 1) @[ISR.scala 39:45]
    io.product_out <= _T_7 @[ISR.scala 39:24]
    io.mplier_out <= nextMplier @[ISR.scala 40:23]
    io.mcand_out <= nextMcand @[ISR.scala 41:22]
    io.done <= doneRegister @[ISR.scala 42:17]
    
  module mult_stage_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip start : UInt<1>, flip product_in : UInt<64>, flip mplier_in : UInt<64>, flip mcand_in : UInt<64>, done : UInt<1>, product_out : UInt<64>, mplier_out : UInt<64>, mcand_out : UInt<64>}
    
    reg productInRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 26:40]
    reg partialProductRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 27:45]
    reg doneRegister : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[ISR.scala 28:35]
    reg nextMplier : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 29:33]
    reg nextMcand : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 30:32]
    node _T = bits(io.mplier_in, 63, 8) @[ISR.scala 32:53]
    node _T_1 = cat(UInt<8>("h00"), _T) @[Cat.scala 29:58]
    nextMplier <= _T_1 @[ISR.scala 32:20]
    node _T_2 = bits(io.mcand_in, 55, 0) @[ISR.scala 33:37]
    node _T_3 = cat(_T_2, UInt<8>("h00")) @[Cat.scala 29:58]
    nextMcand <= _T_3 @[ISR.scala 33:19]
    productInRegister <= io.product_in @[ISR.scala 35:27]
    node _T_4 = bits(io.mplier_in, 7, 0) @[ISR.scala 36:47]
    node _T_5 = mul(_T_4, io.mcand_in) @[ISR.scala 36:62]
    partialProductRegister <= _T_5 @[ISR.scala 36:32]
    doneRegister <= io.start @[ISR.scala 37:22]
    node _T_6 = add(productInRegister, partialProductRegister) @[ISR.scala 39:45]
    node _T_7 = tail(_T_6, 1) @[ISR.scala 39:45]
    io.product_out <= _T_7 @[ISR.scala 39:24]
    io.mplier_out <= nextMplier @[ISR.scala 40:23]
    io.mcand_out <= nextMcand @[ISR.scala 41:22]
    io.done <= doneRegister @[ISR.scala 42:17]
    
  module mult_stage_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip start : UInt<1>, flip product_in : UInt<64>, flip mplier_in : UInt<64>, flip mcand_in : UInt<64>, done : UInt<1>, product_out : UInt<64>, mplier_out : UInt<64>, mcand_out : UInt<64>}
    
    reg productInRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 26:40]
    reg partialProductRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 27:45]
    reg doneRegister : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[ISR.scala 28:35]
    reg nextMplier : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 29:33]
    reg nextMcand : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 30:32]
    node _T = bits(io.mplier_in, 63, 8) @[ISR.scala 32:53]
    node _T_1 = cat(UInt<8>("h00"), _T) @[Cat.scala 29:58]
    nextMplier <= _T_1 @[ISR.scala 32:20]
    node _T_2 = bits(io.mcand_in, 55, 0) @[ISR.scala 33:37]
    node _T_3 = cat(_T_2, UInt<8>("h00")) @[Cat.scala 29:58]
    nextMcand <= _T_3 @[ISR.scala 33:19]
    productInRegister <= io.product_in @[ISR.scala 35:27]
    node _T_4 = bits(io.mplier_in, 7, 0) @[ISR.scala 36:47]
    node _T_5 = mul(_T_4, io.mcand_in) @[ISR.scala 36:62]
    partialProductRegister <= _T_5 @[ISR.scala 36:32]
    doneRegister <= io.start @[ISR.scala 37:22]
    node _T_6 = add(productInRegister, partialProductRegister) @[ISR.scala 39:45]
    node _T_7 = tail(_T_6, 1) @[ISR.scala 39:45]
    io.product_out <= _T_7 @[ISR.scala 39:24]
    io.mplier_out <= nextMplier @[ISR.scala 40:23]
    io.mcand_out <= nextMcand @[ISR.scala 41:22]
    io.done <= doneRegister @[ISR.scala 42:17]
    
  module mult_stage_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip start : UInt<1>, flip product_in : UInt<64>, flip mplier_in : UInt<64>, flip mcand_in : UInt<64>, done : UInt<1>, product_out : UInt<64>, mplier_out : UInt<64>, mcand_out : UInt<64>}
    
    reg productInRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 26:40]
    reg partialProductRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 27:45]
    reg doneRegister : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[ISR.scala 28:35]
    reg nextMplier : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 29:33]
    reg nextMcand : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 30:32]
    node _T = bits(io.mplier_in, 63, 8) @[ISR.scala 32:53]
    node _T_1 = cat(UInt<8>("h00"), _T) @[Cat.scala 29:58]
    nextMplier <= _T_1 @[ISR.scala 32:20]
    node _T_2 = bits(io.mcand_in, 55, 0) @[ISR.scala 33:37]
    node _T_3 = cat(_T_2, UInt<8>("h00")) @[Cat.scala 29:58]
    nextMcand <= _T_3 @[ISR.scala 33:19]
    productInRegister <= io.product_in @[ISR.scala 35:27]
    node _T_4 = bits(io.mplier_in, 7, 0) @[ISR.scala 36:47]
    node _T_5 = mul(_T_4, io.mcand_in) @[ISR.scala 36:62]
    partialProductRegister <= _T_5 @[ISR.scala 36:32]
    doneRegister <= io.start @[ISR.scala 37:22]
    node _T_6 = add(productInRegister, partialProductRegister) @[ISR.scala 39:45]
    node _T_7 = tail(_T_6, 1) @[ISR.scala 39:45]
    io.product_out <= _T_7 @[ISR.scala 39:24]
    io.mplier_out <= nextMplier @[ISR.scala 40:23]
    io.mcand_out <= nextMcand @[ISR.scala 41:22]
    io.done <= doneRegister @[ISR.scala 42:17]
    
  module mult_stage_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip start : UInt<1>, flip product_in : UInt<64>, flip mplier_in : UInt<64>, flip mcand_in : UInt<64>, done : UInt<1>, product_out : UInt<64>, mplier_out : UInt<64>, mcand_out : UInt<64>}
    
    reg productInRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 26:40]
    reg partialProductRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 27:45]
    reg doneRegister : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[ISR.scala 28:35]
    reg nextMplier : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 29:33]
    reg nextMcand : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 30:32]
    node _T = bits(io.mplier_in, 63, 8) @[ISR.scala 32:53]
    node _T_1 = cat(UInt<8>("h00"), _T) @[Cat.scala 29:58]
    nextMplier <= _T_1 @[ISR.scala 32:20]
    node _T_2 = bits(io.mcand_in, 55, 0) @[ISR.scala 33:37]
    node _T_3 = cat(_T_2, UInt<8>("h00")) @[Cat.scala 29:58]
    nextMcand <= _T_3 @[ISR.scala 33:19]
    productInRegister <= io.product_in @[ISR.scala 35:27]
    node _T_4 = bits(io.mplier_in, 7, 0) @[ISR.scala 36:47]
    node _T_5 = mul(_T_4, io.mcand_in) @[ISR.scala 36:62]
    partialProductRegister <= _T_5 @[ISR.scala 36:32]
    doneRegister <= io.start @[ISR.scala 37:22]
    node _T_6 = add(productInRegister, partialProductRegister) @[ISR.scala 39:45]
    node _T_7 = tail(_T_6, 1) @[ISR.scala 39:45]
    io.product_out <= _T_7 @[ISR.scala 39:24]
    io.mplier_out <= nextMplier @[ISR.scala 40:23]
    io.mcand_out <= nextMcand @[ISR.scala 41:22]
    io.done <= doneRegister @[ISR.scala 42:17]
    
  module mult_stage_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip start : UInt<1>, flip product_in : UInt<64>, flip mplier_in : UInt<64>, flip mcand_in : UInt<64>, done : UInt<1>, product_out : UInt<64>, mplier_out : UInt<64>, mcand_out : UInt<64>}
    
    reg productInRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 26:40]
    reg partialProductRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 27:45]
    reg doneRegister : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[ISR.scala 28:35]
    reg nextMplier : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 29:33]
    reg nextMcand : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 30:32]
    node _T = bits(io.mplier_in, 63, 8) @[ISR.scala 32:53]
    node _T_1 = cat(UInt<8>("h00"), _T) @[Cat.scala 29:58]
    nextMplier <= _T_1 @[ISR.scala 32:20]
    node _T_2 = bits(io.mcand_in, 55, 0) @[ISR.scala 33:37]
    node _T_3 = cat(_T_2, UInt<8>("h00")) @[Cat.scala 29:58]
    nextMcand <= _T_3 @[ISR.scala 33:19]
    productInRegister <= io.product_in @[ISR.scala 35:27]
    node _T_4 = bits(io.mplier_in, 7, 0) @[ISR.scala 36:47]
    node _T_5 = mul(_T_4, io.mcand_in) @[ISR.scala 36:62]
    partialProductRegister <= _T_5 @[ISR.scala 36:32]
    doneRegister <= io.start @[ISR.scala 37:22]
    node _T_6 = add(productInRegister, partialProductRegister) @[ISR.scala 39:45]
    node _T_7 = tail(_T_6, 1) @[ISR.scala 39:45]
    io.product_out <= _T_7 @[ISR.scala 39:24]
    io.mplier_out <= nextMplier @[ISR.scala 40:23]
    io.mcand_out <= nextMcand @[ISR.scala 41:22]
    io.done <= doneRegister @[ISR.scala 42:17]
    
  module mult_stage_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip start : UInt<1>, flip product_in : UInt<64>, flip mplier_in : UInt<64>, flip mcand_in : UInt<64>, done : UInt<1>, product_out : UInt<64>, mplier_out : UInt<64>, mcand_out : UInt<64>}
    
    reg productInRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 26:40]
    reg partialProductRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 27:45]
    reg doneRegister : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[ISR.scala 28:35]
    reg nextMplier : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 29:33]
    reg nextMcand : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 30:32]
    node _T = bits(io.mplier_in, 63, 8) @[ISR.scala 32:53]
    node _T_1 = cat(UInt<8>("h00"), _T) @[Cat.scala 29:58]
    nextMplier <= _T_1 @[ISR.scala 32:20]
    node _T_2 = bits(io.mcand_in, 55, 0) @[ISR.scala 33:37]
    node _T_3 = cat(_T_2, UInt<8>("h00")) @[Cat.scala 29:58]
    nextMcand <= _T_3 @[ISR.scala 33:19]
    productInRegister <= io.product_in @[ISR.scala 35:27]
    node _T_4 = bits(io.mplier_in, 7, 0) @[ISR.scala 36:47]
    node _T_5 = mul(_T_4, io.mcand_in) @[ISR.scala 36:62]
    partialProductRegister <= _T_5 @[ISR.scala 36:32]
    doneRegister <= io.start @[ISR.scala 37:22]
    node _T_6 = add(productInRegister, partialProductRegister) @[ISR.scala 39:45]
    node _T_7 = tail(_T_6, 1) @[ISR.scala 39:45]
    io.product_out <= _T_7 @[ISR.scala 39:24]
    io.mplier_out <= nextMplier @[ISR.scala 40:23]
    io.mcand_out <= nextMcand @[ISR.scala 41:22]
    io.done <= doneRegister @[ISR.scala 42:17]
    
  module mult_stage_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip start : UInt<1>, flip product_in : UInt<64>, flip mplier_in : UInt<64>, flip mcand_in : UInt<64>, done : UInt<1>, product_out : UInt<64>, mplier_out : UInt<64>, mcand_out : UInt<64>}
    
    reg productInRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 26:40]
    reg partialProductRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 27:45]
    reg doneRegister : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[ISR.scala 28:35]
    reg nextMplier : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 29:33]
    reg nextMcand : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 30:32]
    node _T = bits(io.mplier_in, 63, 8) @[ISR.scala 32:53]
    node _T_1 = cat(UInt<8>("h00"), _T) @[Cat.scala 29:58]
    nextMplier <= _T_1 @[ISR.scala 32:20]
    node _T_2 = bits(io.mcand_in, 55, 0) @[ISR.scala 33:37]
    node _T_3 = cat(_T_2, UInt<8>("h00")) @[Cat.scala 29:58]
    nextMcand <= _T_3 @[ISR.scala 33:19]
    productInRegister <= io.product_in @[ISR.scala 35:27]
    node _T_4 = bits(io.mplier_in, 7, 0) @[ISR.scala 36:47]
    node _T_5 = mul(_T_4, io.mcand_in) @[ISR.scala 36:62]
    partialProductRegister <= _T_5 @[ISR.scala 36:32]
    doneRegister <= io.start @[ISR.scala 37:22]
    node _T_6 = add(productInRegister, partialProductRegister) @[ISR.scala 39:45]
    node _T_7 = tail(_T_6, 1) @[ISR.scala 39:45]
    io.product_out <= _T_7 @[ISR.scala 39:24]
    io.mplier_out <= nextMplier @[ISR.scala 40:23]
    io.mcand_out <= nextMcand @[ISR.scala 41:22]
    io.done <= doneRegister @[ISR.scala 42:17]
    
  module pipe_mult : 
    input clock : Clock
    input reset : Reset
    output io : {flip start : UInt<1>, flip mplier : UInt<64>, flip mcand : UInt<64>, product : UInt<64>, done : UInt<1>}
    
    wire mcandOut : UInt<64> @[ISR.scala 57:28]
    wire mplierOut : UInt<64> @[ISR.scala 58:29]
    wire internalProducts : UInt<64>[7] @[ISR.scala 60:36]
    wire internalMcands : UInt<64>[7] @[ISR.scala 61:34]
    wire internalMpliers : UInt<64>[7] @[ISR.scala 62:35]
    wire internalDones : UInt<1>[7] @[ISR.scala 63:33]
    inst mult_stage of mult_stage @[ISR.scala 64:49]
    mult_stage.clock <= clock
    mult_stage.reset <= reset
    inst mult_stage_1 of mult_stage_1 @[ISR.scala 64:49]
    mult_stage_1.clock <= clock
    mult_stage_1.reset <= reset
    inst mult_stage_2 of mult_stage_2 @[ISR.scala 64:49]
    mult_stage_2.clock <= clock
    mult_stage_2.reset <= reset
    inst mult_stage_3 of mult_stage_3 @[ISR.scala 64:49]
    mult_stage_3.clock <= clock
    mult_stage_3.reset <= reset
    inst mult_stage_4 of mult_stage_4 @[ISR.scala 64:49]
    mult_stage_4.clock <= clock
    mult_stage_4.reset <= reset
    inst mult_stage_5 of mult_stage_5 @[ISR.scala 64:49]
    mult_stage_5.clock <= clock
    mult_stage_5.reset <= reset
    inst mult_stage_6 of mult_stage_6 @[ISR.scala 64:49]
    mult_stage_6.clock <= clock
    mult_stage_6.reset <= reset
    inst mult_stage_7 of mult_stage_7 @[ISR.scala 64:49]
    mult_stage_7.clock <= clock
    mult_stage_7.reset <= reset
    mult_stage.io.product_in <= UInt<64>("h00") @[ISR.scala 69:46]
    mult_stage.io.mplier_in <= io.mplier @[ISR.scala 70:45]
    mult_stage.io.mcand_in <= io.mcand @[ISR.scala 71:44]
    mult_stage.io.start <= io.start @[ISR.scala 72:41]
    internalProducts[0] <= mult_stage.io.product_out @[ISR.scala 88:45]
    internalDones[0] <= mult_stage.io.done @[ISR.scala 89:42]
    internalMpliers[0] <= mult_stage.io.mplier_out @[ISR.scala 90:44]
    internalMcands[0] <= mult_stage.io.mcand_out @[ISR.scala 91:43]
    mult_stage_1.io.product_in <= internalProducts[0] @[ISR.scala 75:46]
    mult_stage_1.io.mplier_in <= internalMpliers[0] @[ISR.scala 76:45]
    mult_stage_1.io.mcand_in <= internalMcands[0] @[ISR.scala 77:44]
    mult_stage_1.io.start <= internalDones[0] @[ISR.scala 78:41]
    internalProducts[1] <= mult_stage_1.io.product_out @[ISR.scala 88:45]
    internalDones[1] <= mult_stage_1.io.done @[ISR.scala 89:42]
    internalMpliers[1] <= mult_stage_1.io.mplier_out @[ISR.scala 90:44]
    internalMcands[1] <= mult_stage_1.io.mcand_out @[ISR.scala 91:43]
    mult_stage_2.io.product_in <= internalProducts[1] @[ISR.scala 75:46]
    mult_stage_2.io.mplier_in <= internalMpliers[1] @[ISR.scala 76:45]
    mult_stage_2.io.mcand_in <= internalMcands[1] @[ISR.scala 77:44]
    mult_stage_2.io.start <= internalDones[1] @[ISR.scala 78:41]
    internalProducts[2] <= mult_stage_2.io.product_out @[ISR.scala 88:45]
    internalDones[2] <= mult_stage_2.io.done @[ISR.scala 89:42]
    internalMpliers[2] <= mult_stage_2.io.mplier_out @[ISR.scala 90:44]
    internalMcands[2] <= mult_stage_2.io.mcand_out @[ISR.scala 91:43]
    mult_stage_3.io.product_in <= internalProducts[2] @[ISR.scala 75:46]
    mult_stage_3.io.mplier_in <= internalMpliers[2] @[ISR.scala 76:45]
    mult_stage_3.io.mcand_in <= internalMcands[2] @[ISR.scala 77:44]
    mult_stage_3.io.start <= internalDones[2] @[ISR.scala 78:41]
    internalProducts[3] <= mult_stage_3.io.product_out @[ISR.scala 88:45]
    internalDones[3] <= mult_stage_3.io.done @[ISR.scala 89:42]
    internalMpliers[3] <= mult_stage_3.io.mplier_out @[ISR.scala 90:44]
    internalMcands[3] <= mult_stage_3.io.mcand_out @[ISR.scala 91:43]
    mult_stage_4.io.product_in <= internalProducts[3] @[ISR.scala 75:46]
    mult_stage_4.io.mplier_in <= internalMpliers[3] @[ISR.scala 76:45]
    mult_stage_4.io.mcand_in <= internalMcands[3] @[ISR.scala 77:44]
    mult_stage_4.io.start <= internalDones[3] @[ISR.scala 78:41]
    internalProducts[4] <= mult_stage_4.io.product_out @[ISR.scala 88:45]
    internalDones[4] <= mult_stage_4.io.done @[ISR.scala 89:42]
    internalMpliers[4] <= mult_stage_4.io.mplier_out @[ISR.scala 90:44]
    internalMcands[4] <= mult_stage_4.io.mcand_out @[ISR.scala 91:43]
    mult_stage_5.io.product_in <= internalProducts[4] @[ISR.scala 75:46]
    mult_stage_5.io.mplier_in <= internalMpliers[4] @[ISR.scala 76:45]
    mult_stage_5.io.mcand_in <= internalMcands[4] @[ISR.scala 77:44]
    mult_stage_5.io.start <= internalDones[4] @[ISR.scala 78:41]
    internalProducts[5] <= mult_stage_5.io.product_out @[ISR.scala 88:45]
    internalDones[5] <= mult_stage_5.io.done @[ISR.scala 89:42]
    internalMpliers[5] <= mult_stage_5.io.mplier_out @[ISR.scala 90:44]
    internalMcands[5] <= mult_stage_5.io.mcand_out @[ISR.scala 91:43]
    mult_stage_6.io.product_in <= internalProducts[5] @[ISR.scala 75:46]
    mult_stage_6.io.mplier_in <= internalMpliers[5] @[ISR.scala 76:45]
    mult_stage_6.io.mcand_in <= internalMcands[5] @[ISR.scala 77:44]
    mult_stage_6.io.start <= internalDones[5] @[ISR.scala 78:41]
    internalProducts[6] <= mult_stage_6.io.product_out @[ISR.scala 88:45]
    internalDones[6] <= mult_stage_6.io.done @[ISR.scala 89:42]
    internalMpliers[6] <= mult_stage_6.io.mplier_out @[ISR.scala 90:44]
    internalMcands[6] <= mult_stage_6.io.mcand_out @[ISR.scala 91:43]
    mult_stage_7.io.product_in <= internalProducts[6] @[ISR.scala 75:46]
    mult_stage_7.io.mplier_in <= internalMpliers[6] @[ISR.scala 76:45]
    mult_stage_7.io.mcand_in <= internalMcands[6] @[ISR.scala 77:44]
    mult_stage_7.io.start <= internalDones[6] @[ISR.scala 78:41]
    io.product <= mult_stage_7.io.product_out @[ISR.scala 82:36]
    io.done <= mult_stage_7.io.done @[ISR.scala 83:33]
    mplierOut <= mult_stage_7.io.mplier_out @[ISR.scala 84:35]
    mcandOut <= mult_stage_7.io.mcand_out @[ISR.scala 85:34]
    
  module ISR : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip value : UInt<64>, result : UInt<32>, done : UInt<1>}
    
    wire start : UInt<1> @[ISR.scala 112:25]
    wire guessDone : UInt<1> @[ISR.scala 113:29]
    reg valueRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 115:36]
    reg resultRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 116:37]
    reg guessResultRegister : UInt<64>, clock with : (reset => (reset, UInt<64>("h00"))) @[ISR.scala 117:42]
    reg state : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[ISR.scala 119:28]
    reg nextState : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[ISR.scala 120:32]
    reg index : UInt<6>, clock with : (reset => (reset, UInt<6>("h020"))) @[ISR.scala 122:28]
    reg nextIndex : UInt<6>, clock with : (reset => (reset, UInt<6>("h020"))) @[ISR.scala 123:32]
    inst multPipeline of pipe_mult @[ISR.scala 125:34]
    multPipeline.clock <= clock
    multPipeline.reset <= reset
    multPipeline.io.mcand <= resultRegister @[ISR.scala 126:31]
    multPipeline.io.mplier <= resultRegister @[ISR.scala 127:32]
    multPipeline.io.start <= start @[ISR.scala 128:31]
    guessResultRegister <= multPipeline.io.product @[ISR.scala 129:29]
    guessDone <= multPipeline.io.done @[ISR.scala 130:19]
    start <= UInt<1>("h00") @[ISR.scala 132:15]
    io.done <= UInt<1>("h00") @[ISR.scala 133:17]
    valueRegister <= io.value @[ISR.scala 135:23]
    index <= nextIndex @[ISR.scala 136:15]
    state <= nextState @[ISR.scala 137:15]
    node _T = bits(resultRegister, 31, 0) @[ISR.scala 138:36]
    io.result <= _T @[ISR.scala 138:19]
    node _T_1 = eq(UInt<1>("h00"), state) @[Conditional.scala 37:30]
    when _T_1 : @[Conditional.scala 40:58]
      nextState <= UInt<1>("h01") @[ISR.scala 142:35]
      start <= UInt<1>("h00") @[ISR.scala 143:31]
      resultRegister <= UInt<1>("h00") @[ISR.scala 144:40]
      io.done <= UInt<1>("h00") @[ISR.scala 145:33]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_2 = eq(UInt<1>("h01"), state) @[Conditional.scala 37:30]
      when _T_2 : @[Conditional.scala 39:67]
        node _T_3 = gt(index, UInt<1>("h00")) @[ISR.scala 148:37]
        when _T_3 : @[ISR.scala 148:44]
          nextState <= UInt<2>("h02") @[ISR.scala 149:43]
          start <= UInt<1>("h01") @[ISR.scala 150:39]
          node _T_4 = sub(index, UInt<1>("h01")) @[ISR.scala 151:83]
          node _T_5 = tail(_T_4, 1) @[ISR.scala 151:83]
          node _T_6 = dshl(UInt<1>("h01"), _T_5) @[ISR.scala 151:73]
          node _T_7 = or(resultRegister, _T_6) @[ISR.scala 151:66]
          resultRegister <= _T_7 @[ISR.scala 151:48]
          skip @[ISR.scala 148:44]
        else : @[ISR.scala 152:37]
          nextState <= UInt<3>("h04") @[ISR.scala 153:43]
          skip @[ISR.scala 152:37]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), state) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          start <= UInt<1>("h00") @[ISR.scala 157:31]
          node _T_9 = eq(guessDone, UInt<1>("h01")) @[ISR.scala 158:41]
          when _T_9 : @[ISR.scala 158:50]
            nextState <= UInt<2>("h03") @[ISR.scala 159:43]
            skip @[ISR.scala 158:50]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_10 = eq(UInt<2>("h03"), state) @[Conditional.scala 37:30]
          when _T_10 : @[Conditional.scala 39:67]
            node _T_11 = sub(index, UInt<1>("h01")) @[ISR.scala 163:44]
            node _T_12 = tail(_T_11, 1) @[ISR.scala 163:44]
            nextIndex <= _T_12 @[ISR.scala 163:35]
            node _T_13 = eq(guessResultRegister, valueRegister) @[ISR.scala 164:51]
            when _T_13 : @[ISR.scala 164:70]
              nextState <= UInt<3>("h04") @[ISR.scala 165:43]
              skip @[ISR.scala 164:70]
            else : @[ISR.scala 166:74]
              node _T_14 = gt(guessResultRegister, valueRegister) @[ISR.scala 166:57]
              when _T_14 : @[ISR.scala 166:74]
                node _T_15 = sub(index, UInt<1>("h01")) @[ISR.scala 167:84]
                node _T_16 = tail(_T_15, 1) @[ISR.scala 167:84]
                node _T_17 = dshl(UInt<1>("h01"), _T_16) @[ISR.scala 167:74]
                node _T_18 = not(_T_17) @[ISR.scala 167:68]
                node _T_19 = and(resultRegister, _T_18) @[ISR.scala 167:66]
                resultRegister <= _T_19 @[ISR.scala 167:48]
                nextState <= UInt<1>("h01") @[ISR.scala 168:43]
                skip @[ISR.scala 166:74]
              else : @[ISR.scala 169:37]
                nextState <= UInt<1>("h01") @[ISR.scala 170:43]
                skip @[ISR.scala 169:37]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_20 = eq(UInt<3>("h04"), state) @[Conditional.scala 37:30]
            when _T_20 : @[Conditional.scala 39:67]
              io.done <= UInt<1>("h01") @[ISR.scala 174:33]
              nextState <= UInt<1>("h00") @[ISR.scala 175:35]
              nextIndex <= UInt<6>("h020") @[ISR.scala 176:35]
              skip @[Conditional.scala 39:67]
    
